package Analizadores;

import java.util.Arrays;
import java.util.LinkedList;
import java_cup.runtime.*;
import Errores.Error_;
import GUI.gui;
import DB.ts;
import java.util.HashMap;
import java.util.Map;
import DB.ImageCreator;
import java.util.HashSet;
import java.util.Set;
import java.io.File;
import java.io.IOException;

import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.plot.PlotOrientation;


parser code
{:
    public static String concatenarArreglos(double[] sinR, int[] frec, int[] frecA, double[] frecR) {
        StringBuilder resultado = new StringBuilder();

        for (int i = 0; i < sinR.length; i++) {
            // Concatenar valores de cada arreglo, separados por tabuladores
            resultado.append(sinR[i]).append("\t").append(frec[i]).append("\t").append(frecA[i]).append("\t").append(frecR[i]);

            // Agregar un salto de línea después de cada conjunto de valores
            resultado.append("%"+"\n");
        }

        return resultado.toString();
    }

    public static double[] obtenerArregloSinRepetidos(double[] arreglo) {
        Set<Double> valoresUnicos = new HashSet<>();

        // Agregar valores únicos al conjunto
        for (double valor : arreglo) {
            valoresUnicos.add(valor);
        }

        // Convertir el conjunto a un arreglo
        double[] resultado = new double[valoresUnicos.size()];
        int index = 0;
        for (double valor : valoresUnicos) {
            resultado[index++] = valor;
        }

        return resultado;
    }

    public static int[] obtenerFrecuencia(double[] arreglo) {
        Map<Double, Integer> mapaFrecuencia = new HashMap<>();

        // Contar frecuencia de cada valor
        for (double valor : arreglo) {
            mapaFrecuencia.put(valor, mapaFrecuencia.getOrDefault(valor, 0) + 1);
        }

        // Convertir el mapa a un arreglo de frecuencia
        int[] frecuencia = new int[mapaFrecuencia.size()];
        int index = 0;
        for (double valor : mapaFrecuencia.keySet()) {
            frecuencia[index++] = mapaFrecuencia.get(valor);
        }

        return frecuencia;
    }

    public static int[] obtenerFrecuenciaAcumulada(int[] frecuencia) {
        int[] frecuenciaAcumulada = new int[frecuencia.length];
        int acumulada = 0;

        for (int i = 0; i < frecuencia.length; i++) {
            acumulada += frecuencia[i];
            frecuenciaAcumulada[i] = acumulada;
        }

        return frecuenciaAcumulada;
    }

    public static double[] obtenerFrecuenciaRelativa(int[] frecuencia, int totalElementos) {
        double[] frecuenciaRelativa = new double[frecuencia.length];
        double num=0;

        for (int i = 0; i < frecuencia.length; i++) {
            num=(double) frecuencia[i] / totalElementos;
            num=num*100;
            int numR = (int) Math.round(num);
            frecuenciaRelativa[i] = numR;
        }

        return frecuenciaRelativa;
    }



public static String[] dividirStringPorComillas(String cadena) {
    String[] resultado = new String[2];

    // Encuentra la posición de la primera comilla doble
    int indiceComilla = cadena.indexOf("\"");

    // Verifica si se encontró una comilla doble
    if (indiceComilla != -1) {
        // Divide la cadena en dos partes
        resultado[0] = cadena.substring(0, indiceComilla);
        resultado[1] = cadena.substring(indiceComilla);
    } else {
        // Si no se encontró una comilla doble, asigna la cadena completa a la primera parte
        resultado[0] = cadena;
        resultado[1] = "";
    }

    return resultado;
}

    public static float calcularMaximo(float[] numeros) {
        float maximo = Integer.MIN_VALUE;

        for (float numero : numeros) {
            if (numero > maximo) {
                maximo = numero;
            }
        }

        return maximo;
    }
private static int[] convertirDoubleAInt(double[] arregloDouble) {
        int[] arregloInt = new int[arregloDouble.length];

        for (int i = 0; i < arregloDouble.length; i++) {
            // Convertir cada elemento de double a int
            arregloInt[i] = (int) arregloDouble[i];
        }

        return arregloInt;
    }
    public static float calcularMinimo(float[] numeros) {
        float minimo = Integer.MAX_VALUE;

        for (float numero : numeros) {
            if (numero < minimo) {
                minimo = numero;
            }
        }

        return minimo;
    }

    
      public static double calcularVarianza(float[] numeros) {
        // Calcular la media
        double media = calcularMedia(numeros);

        // Calcular la suma de los cuadrados de las diferencias entre cada número y la media
        double sumaCuadradosDiferencias = 0;

        for (float numero : numeros) {
            double diferencia = numero - media;
            sumaCuadradosDiferencias += diferencia * diferencia;
        }

        // Calcular la varianza dividiendo la suma de los cuadrados por la cantidad de elementos
        double varianza = sumaCuadradosDiferencias / numeros.length;

        return varianza;
    }

     public static double calcularMedia(float[] numeros) {
        float suma = 0;

        for (float numero : numeros) {
            suma += numero;
        }

        return (double) suma / numeros.length;
    }

     public static double calcularModa(float[] numeros) {
    // Utilizamos un mapa para almacenar la frecuencia de cada número
    Map<Float, Integer> frecuenciaMapa = new HashMap<>();

    // Calcular la frecuencia de cada número
    for (float numero : numeros) {
        frecuenciaMapa.put(numero, frecuenciaMapa.getOrDefault(numero, 0) + 1);
    }

    // Encontrar el número con la frecuencia máxima
    double moda = 0;
    int frecuenciaMaxima = 0;

    for (Map.Entry<Float, Integer> entry : frecuenciaMapa.entrySet()) {
        float numero = entry.getKey();
        int frecuencia = entry.getValue();

        if (frecuencia > frecuenciaMaxima) {
            moda = numero;
            frecuenciaMaxima = frecuencia;
        }
    }

    return moda;
}
    
    public static float[] convertirCadenaAArray(String numerosString) {
    String[] numerosStringArray = numerosString.split(",");
    float[] numeros = new float[numerosStringArray.length];

    for (int i = 0; i < numerosStringArray.length; i++) {
        numeros[i] = Float.parseFloat(numerosStringArray[i]);
    }

    return numeros;
}
public static double[] convertirStringADoubleArray(String cadena) {
    // Divide la cadena por comas y convierte cada elemento a double
    String[] numerosString = cadena.split(",");
    double[] numeros = new double[numerosString.length];

    for (int i = 0; i < numerosString.length; i++) {
        numeros[i] = Double.parseDouble(numerosString[i]);
    }

    return numeros;
}

   public static double calcularMediana(float[] numeros) {
    int n = numeros.length;
    if (n % 2 == 0) {
        // Si hay un número par de elementos, promediar los dos valores centrales
        int indice1 = n / 2 - 1;
        int indice2 = n / 2;
        return (numeros[indice1] + numeros[indice2]) / 2.0;
    } else {
        // Si hay un número impar de elementos, devolver el valor central
        int indiceCentral = n / 2;
        return numeros[indiceCentral];
    }
}

    
    public static String arregloTemporal="";
    public static String arregloNumeros="";

    public static String tituloGG="";
    public static String ejexGG="";
    public static String ejeyGG="";
    public static String tituloxGG="";
    public static String tituloyGG="";
    public static String labelGG="";
    public static String valuesGG="";
   
    public static String obtenerValor(LinkedList<ts> lista, String nombreBuscado) {
        for (ts item : lista) {
            if (item.getNombre().equals(nombreBuscado)) {
                return item.getValor();
            }
        }
        return null; // Retorna null si no se encuentra el nodo
    }





    public void syntax_error(Symbol s)
    {
        //System.out.println("Error de sintaxis en la linea " + (s.left) + ", columna " + (s.right) + ". No se esperaba " + s.value);
        Error_ nuevoError = new Error_(s.left,s.right,"No se esperaba el siguiente token: "+s.value.toString(),false);
        gui.lista_errores.add(nuevoError);
    }



    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        System.out.println("Error de sintaxis en la linea " + (s.left) + ", columna " + (s.right) + ". No se esperaba " + s.value );
        Error_ nuevoError = new Error_(s.left,s.right,"No se esperaba el siguiente token: "+s.value.toString(),false);
        gui.lista_errores.add(nuevoError);
    }
 
:}


terminal ID,DOS_PUNTOS,MENOR_QUE,MAYOR_QUE,GUION,PUNTO,COMA,PUNTO_Y_COMA,PARENTESIS_IZQUIERDO,
PARENTESIS_DERECHO, CORCHETE_IZQUIERDO, CORCHETE_DERECHO, SIGNO_IGUAL,RESERVADA_PROGRAM,
RESERVADA_END, RESERVADA_VAR, RESERVADA_DOUBLE, RESERVADA_CHAR, RESERVADA_ARRAY, RESERVADA_SUMA,
RESERVADA_RESTA, RESERVADA_MULTIPLICACION, RESERVADA_DIVISION, RESERVADA_MODULO, RESERVADA_MEDIA, 
RESERVADA_MEDIANA, RESERVADA_MODA, RESERVADA_VARIANZA, RESERVADA_MAX, RESERVADA_MIN, RESERVADA_CONSOLE,
RESERVADA_PRINT,RESERVADA_COLUMN, RESERVADA_GRAFICA_BARRA, RESERVADA_GRAFICA_PIE, RESERVADA_GRAFICA_LINE,
RESERVADA_GRAFIA_HISTOGRAMA, RESERVADA_TITULO_GRAFICA, RESERVADA_EJEX_GRAFICA, RESERVADA_EJEY_GRAFICA, 
RESERVADA_TITULOX_GRAFICA, RESERVADA_TITULOY_GRAFICA, RESERVADA_VALUES_GRAFICA, RESRVADA_LABEL_GRAFICA,
RESERVADA_EXEC,STRING,NUMEROS,IDE,CERRADURA_LINEA,CERRADURA_PIE,CERRADURA_BARRAS;

//Inicia
non terminal inicio;
non terminal codigo,cod; 
non terminal primitivas,arreglos,print, graficas;
non terminal tipo,dospuntos,contenidoVariable,aritmeticas,estadisticas;
non terminal cuerpoLista,listaValores;
non terminal media, mediana, moda,varianza,max,min,contenidoE;
non terminal suma,resta,multiplicacion,division, modulo,valorAritmetico,tipoAnidada,anidacion;
non terminal desicionprint,print1,valorPrint,combinado,combinacion,comb,print2,pp,ppp;
non terminal pie,barras,linea,histograma;
non terminal sentencias,sentencias2,sentencias3,ejexG,ejeyG,tituloxG,tituloyG,tituloG,labelG,valuesG;

start with inicio;

inicio::= RESERVADA_PROGRAM codigo RESERVADA_END RESERVADA_PROGRAM;

codigo::= cod|cod codigo;
cod::=primitivas|arreglos|print|graficas;

//==============================================================================
tipo::= RESERVADA_CHAR CORCHETE_IZQUIERDO CORCHETE_DERECHO {:RESULT="CHAR[]";:}|RESERVADA_DOUBLE{:RESULT="DOUBLE";:};
dospuntos::=DOS_PUNTOS DOS_PUNTOS;
//Variables
contenidoVariable::= NUMEROS:n{:RESULT=n.toString();:}
                    |ID:id {: RESULT = obtenerValor(gui.listaSimbolos,(String) id);:}
                    |STRING:s {:RESULT=s.toString();:}
                    |aritmeticas:a {:RESULT=a.toString();:}
                    |estadisticas:e {:RESULT=e.toString();:};

//Arreglos
//============================ Lista Valores ===================================
//llevara arreglo tanto double como char, no importa ya que solo evaluara sintaxis no sentido
listaValores::= CORCHETE_IZQUIERDO cuerpoLista:cl CORCHETE_DERECHO {:arregloNumeros=arregloTemporal;
                System.out.println(" arrS:"+arregloTemporal+" arrN:"+arregloNumeros);:};

cuerpoLista::=STRING:c COMA cuerpoLista {:arregloTemporal=c.toString()+","+arregloTemporal;:}
              |NUMEROS:c COMA cuerpoLista {:arregloTemporal=c.toString()+","+arregloTemporal;:}
              |ID:c COMA cuerpoLista {:arregloTemporal=obtenerValor(gui.listaSimbolos,(String) c)+","+arregloTemporal;:}
              |aritmeticas:c COMA cuerpoLista {:arregloTemporal=c.toString()+","+arregloTemporal;:}
              |estadisticas:c COMA cuerpoLista {:arregloTemporal=c.toString()+","+arregloTemporal;:}

              |STRING:c {:arregloTemporal=c.toString()+arregloTemporal;:}
              |NUMEROS:c {:arregloTemporal=c.toString()+arregloTemporal;:}
              |ID:c      {:arregloTemporal=obtenerValor(gui.listaSimbolos,(String) c)+arregloTemporal;:}
              |aritmeticas:c {:arregloTemporal=c.toString()+arregloTemporal;:}
              |estadisticas:c {:arregloTemporal=c.toString()+arregloTemporal;:};

//==============================================================================

//======================== EMPIEZO CON LAS DECLARACIONES =======================
// char y double
primitivas::= RESERVADA_VAR
                DOS_PUNTOS 
                tipo:t
                dospuntos
                ID:id
                MENOR_QUE GUION
                contenidoVariable:c
                RESERVADA_END PUNTO_Y_COMA
                {:
                ts news = new ts(id.toString(),c.toString(),"Variable tipo "+t.toString(),cleft,cright);
                gui.listaSimbolos.add(news);
                :};

arreglos::= RESERVADA_ARRAY
            DOS_PUNTOS
            tipo:t
            dospuntos
            IDE:ide
            MENOR_QUE GUION
            listaValores:lv
            RESERVADA_END PUNTO_Y_COMA
            {:
                //arregloTemporal="["+arregloTemporal+"]";
                //arregloNumeros=arregloTemporal;
                ts news = new ts(ide.toString(),arregloTemporal,"Array tipo "+t.toString(),lvleft,lvright);
                gui.listaSimbolos.add(news);
                arregloTemporal="";
            :};
//==============================================================================

//================================= aritmeticas ================================ Funciona nice :D
aritmeticas ::= suma:r {:RESULT=r;:}|resta:r{:RESULT=r;:}|multiplicacion:r{:RESULT=r;:}|division:r{:RESULT=r;:}|modulo:r {:RESULT=r;:};

suma::= RESERVADA_SUMA PARENTESIS_IZQUIERDO valorAritmetico:a COMA valorAritmetico:b PARENTESIS_DERECHO  {:
  String strA = a.toString();
  String strB = b.toString();

  float x = Float.parseFloat(strA);
  float y = Float.parseFloat(strB);

  float r = x + y;
  System.out.println("\n" + "Suma es: " + r + "\n");
  RESULT=r; :};


resta::=RESERVADA_RESTA PARENTESIS_IZQUIERDO valorAritmetico:a COMA valorAritmetico:b PARENTESIS_DERECHO {:
  String strA = a.toString();
  String strB = b.toString();

  float x = Float.parseFloat(strA);
  float y = Float.parseFloat(strB);

  float r = x - y;
  System.out.println("\n" + "Resta es: " + r + "\n");
    RESULT=r; :};

multiplicacion::=RESERVADA_MULTIPLICACION PARENTESIS_IZQUIERDO valorAritmetico:a COMA valorAritmetico:b PARENTESIS_DERECHO  {:
  String strA = a.toString();
  String strB = b.toString();

  float x = Float.parseFloat(strA);
  float y = Float.parseFloat(strB);

  float r = x * y;
  System.out.println("\n" + "Multiplicacion es: " + r + "\n"); 
  RESULT=r;  :};

division::=RESERVADA_DIVISION PARENTESIS_IZQUIERDO valorAritmetico:a COMA valorAritmetico:b PARENTESIS_DERECHO {:
  String strA = a.toString();
  String strB = b.toString();

  float x = Float.parseFloat(strA);
  float y = Float.parseFloat(strB);

  float r = x / y;
  System.out.println("\n" + "Division es: " + r + "\n");
  RESULT=r;   :};

modulo::=RESERVADA_MODULO PARENTESIS_IZQUIERDO valorAritmetico:a COMA valorAritmetico:b PARENTESIS_DERECHO  {:
  String strA = a.toString();
  String strB = b.toString();

  float x = Float.parseFloat(strA);
  float y = Float.parseFloat(strB);

  float r = x % y;
  System.out.println("\n" + "Modulo es: " + r + "\n");
  RESULT=r;   :};

tipoAnidada::=RESERVADA_SUMA {:RESULT="suma";:} |RESERVADA_RESTA {:RESULT="resta";:}|RESERVADA_MULTIPLICACION {:RESULT="multiplicacion";:}|RESERVADA_DIVISION {:RESULT="division";:}|RESERVADA_MODULO {:RESULT="modulo";:};

valorAritmetico::= NUMEROS:c {: RESULT= c; :}|ID:c {: RESULT = obtenerValor(gui.listaSimbolos,(String) c);:}|anidacion :c {: RESULT=c; :}|estadisticas:c=1{: RESULT=c; :};//para mientras lo de estadistico===========================
anidacion::= tipoAnidada:to PARENTESIS_IZQUIERDO valorAritmetico:c COMA valorAritmetico:d PARENTESIS_DERECHO {: 
  String strC = c.toString();
  String strD = d.toString();

  float x = Float.parseFloat(strC);
  float y = Float.parseFloat(strD);
  
  if (to.equals("suma")) {
    float r = x + y;
    RESULT = r;
} else if (to.equals("resta")) {
    float r = x - y; // Fix: Change '+' to '-'
    RESULT = r;
} else if (to.equals("multiplicacion")) {
    float r = x * y; 
    RESULT = r;
} else if (to.equals("division")) {
    float r = x / y; 
    RESULT = r;
} else if (to.equals("modulo")) {
    float r = x % y;
    RESULT = r;
}:};

//==============================================================================

//=========================estadisticas=========================================
estadisticas::=media:c {:RESULT=c;:} |mediana:c {:RESULT=c;:} |moda:c {:RESULT=c;:} |varianza:c {:RESULT=c;:} |max:c {:RESULT=c;:} |min:c {:RESULT=c;:} ;

//lista valores es un arreglo double, donde incluye id, numeros, o aritmeticas
contenidoE::=listaValores|IDE:c {:RESULT=obtenerValor(gui.listaSimbolos,(String) c);:};

media::=RESERVADA_MEDIA PARENTESIS_IZQUIERDO contenidoE:c PARENTESIS_DERECHO {: 
       
        if(arregloTemporal.length()==0){
            float[] numeros=convertirCadenaAArray(c.toString());
            double media =calcularMedia(numeros);
            RESULT=media;
        }else{
            float[] numeros=convertirCadenaAArray(arregloTemporal);
            double media =calcularMedia(numeros);
            RESULT=media;
            arregloTemporal="";
            arregloNumeros="";
        }:} ;
mediana::= RESERVADA_MEDIANA PARENTESIS_IZQUIERDO contenidoE:c PARENTESIS_DERECHO {:
        
        if(arregloTemporal.length()==0){
            float[] numeros = convertirCadenaAArray(c.toString());
            Arrays.sort(numeros);
            double mediana = calcularMediana(numeros);
            RESULT=mediana;
        } else {
            float[] numeros = convertirCadenaAArray(arregloTemporal);
            Arrays.sort(numeros);
            double mediana = calcularMediana(numeros);
            RESULT=mediana;
            arregloTemporal="";
            arregloNumeros="";
        }
:} ;
moda::= RESERVADA_MODA PARENTESIS_IZQUIERDO contenidoE:c PARENTESIS_DERECHO {:
 
        if(arregloTemporal.length()==0){
            float[] numeros = convertirCadenaAArray(c.toString());
            double moda = calcularModa(numeros);
            RESULT=moda;
        } else{
            float[] numeros = convertirCadenaAArray(arregloTemporal);
            double moda = calcularModa(numeros);
            RESULT=moda;
            arregloTemporal="";
            arregloNumeros="";
        }
:} ;
varianza::= RESERVADA_VARIANZA PARENTESIS_IZQUIERDO contenidoE:c PARENTESIS_DERECHO {:
    
        if(arregloTemporal.length()==0){
            float[] numeros = convertirCadenaAArray(c.toString());
            double varianza = calcularVarianza(numeros);
            RESULT=varianza;
        } else{
            float[] numeros = convertirCadenaAArray(arregloTemporal);
            double varianza = calcularVarianza(numeros);
            RESULT=varianza;
            arregloTemporal="";
            arregloNumeros="";
        }
:} ;
max::=  RESERVADA_MAX PARENTESIS_IZQUIERDO contenidoE:c PARENTESIS_DERECHO {:

        if(arregloTemporal.length()==0){
            float[] numeros = convertirCadenaAArray(c.toString());
            float maximo = calcularMaximo(numeros);
            RESULT=maximo;
        }else{
            float[] numeros = convertirCadenaAArray(arregloTemporal);
            float maximo = calcularMaximo(numeros);
            RESULT=maximo;
            arregloTemporal="";
            arregloNumeros="";
        }
:} ;
min::= RESERVADA_MIN PARENTESIS_IZQUIERDO contenidoE:c PARENTESIS_DERECHO {:
        
        if(arregloTemporal.length()==0){
            float[] numeros = convertirCadenaAArray(c.toString());
            float minimo = calcularMinimo(numeros);
            RESULT=minimo;
        }else{
            float[] numeros = convertirCadenaAArray(arregloTemporal);
            float minimo = calcularMinimo(numeros);
            RESULT=minimo;
            arregloTemporal="";
            arregloNumeros="";
        }      
:} ;
//==============================================================================

//============================= PRINT =======================================
print::= 
    RESERVADA_CONSOLE:e1
    DOS_PUNTOS:e2 
    DOS_PUNTOS:e3
    desicionprint;

desicionprint::=print1|print2;

print1::=
    RESERVADA_PRINT:e4  
    SIGNO_IGUAL:e5 
    valorPrint:s 
    RESERVADA_END:e6 
    PUNTO_Y_COMA:e7
    {: 
        
String cuer = s.toString().replace("\"", "");
        System.out.println("\n"+"Print desde el cup de la cadena: " + cuer+"\n");
        gui.listaPrint.add(cuer);
    :};



valorPrint ::= STRING:s {: RESULT = s; :}
            | NUMEROS:n {: RESULT = n; :}
            | ID:iddd {: RESULT = obtenerValor(gui.listaSimbolos,(String) iddd);  :}
            | aritmeticas:ar {: RESULT = ar; :}
            | estadisticas:st {: RESULT = st; :}
            | combinado:c {: RESULT = c; :};

combinado ::= combinacion:c combinado:cc {: RESULT = c.toString() + cc.toString(); :}
            | combinacion:c {: RESULT = c.toString(); :}
            | combinacion:c comb:r{: RESULT = c.toString() + r.toString(); :};

combinacion ::= STRING:s COMA {: RESULT = s.toString()+","; :}
             | NUMEROS:n COMA {: RESULT = n.toString()+","; :}
             | aritmeticas:ar COMA {: RESULT = ar.toString()+","; :}
             | estadisticas:st COMA {: RESULT = st.toString()+","; :}
             | ID:iddd COMA {: RESULT = obtenerValor(gui.listaSimbolos,(String) iddd)+",";  :};

comb ::= STRING:s {: RESULT = s; :}
        | ID:iddd {: RESULT = obtenerValor(gui.listaSimbolos,(String) iddd);  :}
        | aritmeticas:ar {: RESULT = ar; :}
        | estadisticas:st {: RESULT = st.toString(); :}
        | NUMEROS:n {: RESULT = n.toString(); :};



print2::=RESERVADA_COLUMN 
        SIGNO_IGUAL
        pp:t
        GUION
        MAYOR_QUE
        ppp:c
        RESERVADA_END
        PUNTO_Y_COMA
        {:
        String cuerpo;
        if(c==null){
            if (arregloTemporal.startsWith("\"")) {         //Char
               cuerpo = arregloTemporal.replaceAll("[\",]", "").replace(",", "\n");
            } else {                                        //Double
               cuerpo =arregloTemporal.replaceAll(",", "\n");
            }
        }else{
            if (c.toString().startsWith("\"")) {         //Char
               cuerpo = c.toString().replaceAll("\"", "").replace(",", "\n");
            } else {                                        //Double
               cuerpo =c.toString().replaceAll(",", "\n");
            }
        }
        int longitud = t.toString().length();
        String lin = "=".repeat(longitud);

        
        cuerpo=lin+"\n"+t.toString()+"\n"+lin+"\n"+cuerpo;
        System.out.println("\n"+"Print desde el cup de la cadena: " + cuerpo+"\n");
        gui.listaPrint.add((String) cuerpo); 
        arregloTemporal="";
        arregloNumeros="";
        :};

pp::=STRING:s {:RESULT=s;:}|ID:id {: RESULT = obtenerValor(gui.listaSimbolos,(String) id);:};
ppp::=IDE:id {: RESULT = obtenerValor(gui.listaSimbolos,(String) id);:}
        |listaValores;//CORCHETE_IZQUIERDO contenidoD ;
//==============================================================================

//====================================================== GRAFICAS =========================================
graficas::=pie|barras|linea|histograma;

sentencias::=tituloG|ejexG|ejeyG|tituloxG|tituloyG;
sentencias2::=labelG|valuesG|tituloG;
sentencias3::=tituloG|valuesG;

tituloG::=RESERVADA_TITULO_GRAFICA
        DOS_PUNTOS DOS_PUNTOS
        RESERVADA_CHAR  CORCHETE_IZQUIERDO CORCHETE_DERECHO SIGNO_IGUAL STRING:t RESERVADA_END PUNTO_Y_COMA
        {:
          tituloGG=t.toString();
        :};

ejexG::=RESERVADA_EJEX_GRAFICA //Normalmente arreglo String
        DOS_PUNTOS DOS_PUNTOS
        RESERVADA_CHAR CORCHETE_IZQUIERDO CORCHETE_DERECHO SIGNO_IGUAL  contenidoE:ex RESERVADA_END PUNTO_Y_COMA
        {:
        if(ex==null){
        ejexGG=arregloTemporal;
        } else{
        ejexGG=ex.toString();
        }
        arregloTemporal="";
        arregloNumeros="";
        :};

ejeyG::=RESERVADA_EJEY_GRAFICA
        DOS_PUNTOS DOS_PUNTOS
        RESERVADA_DOUBLE SIGNO_IGUAL  contenidoE:ey RESERVADA_END PUNTO_Y_COMA
        {:
        if(ey==null){
        ejeyGG=arregloTemporal;
        } else{
        ejeyGG=ey.toString();
        }
        arregloTemporal="";
        arregloNumeros="";
        :};

tituloxG::=RESERVADA_TITULOX_GRAFICA
           DOS_PUNTOS DOS_PUNTOS
           RESERVADA_CHAR CORCHETE_IZQUIERDO CORCHETE_DERECHO SIGNO_IGUAL STRING:x RESERVADA_END PUNTO_Y_COMA
           {:
           tituloxGG=x.toString();
           :};

tituloyG::=RESERVADA_TITULOY_GRAFICA
           DOS_PUNTOS DOS_PUNTOS
           RESERVADA_CHAR CORCHETE_IZQUIERDO CORCHETE_DERECHO SIGNO_IGUAL STRING:y RESERVADA_END PUNTO_Y_COMA
           {:
           tituloyGG=y.toString();
            :};

labelG::=RESRVADA_LABEL_GRAFICA //arreglo cadena
         DOS_PUNTOS DOS_PUNTOS
         RESERVADA_CHAR  CORCHETE_IZQUIERDO CORCHETE_DERECHO SIGNO_IGUAL contenidoE:ex RESERVADA_END PUNTO_Y_COMA
         {:
          if(ex==null){
             labelGG=arregloTemporal;
          } else{
             labelGG=ex.toString();
          }
          arregloTemporal="";
          arregloNumeros="";
         :};

valuesG::=RESERVADA_VALUES_GRAFICA //arreglo numerico
          DOS_PUNTOS DOS_PUNTOS
          tipo SIGNO_IGUAL  contenidoE:ey RESERVADA_END PUNTO_Y_COMA
          {:
          if(ey==null){
             valuesGG=arregloTemporal;
          } else{
             valuesGG=ey.toString();
          }
          arregloTemporal="";
          arregloNumeros="";
          :};


barras::=RESERVADA_GRAFICA_BARRA
        PARENTESIS_IZQUIERDO

        sentencias

        sentencias 

        sentencias 

        sentencias

        sentencias

        RESERVADA_EXEC RESERVADA_GRAFICA_BARRA  RESERVADA_END PUNTO_Y_COMA
     
        PARENTESIS_DERECHO  RESERVADA_END  PUNTO_Y_COMA

        {:
        String[] categorias = ejexGG.replaceAll("\"", "").split(",");
        double[] valores = convertirStringADoubleArray(ejeyGG);
        
        ImageCreator.createBarChartImage(categorias,valores,tituloGG,tituloxGG,tituloyGG);
        arregloTemporal="";
        arregloNumeros="";
        tituloGG="";
        ejexGG="";
        ejeyGG="";
        tituloxGG="";
        tituloyGG="";
        :};


pie::=  RESERVADA_GRAFICA_PIE
        PARENTESIS_IZQUIERDO

        sentencias2
        sentencias2
        sentencias2

        RESERVADA_EXEC  RESERVADA_GRAFICA_PIE  RESERVADA_END PUNTO_Y_COMA
    
        PARENTESIS_DERECHO  RESERVADA_END  PUNTO_Y_COMA

        {:
        String[] categorias = labelGG.replaceAll("\"", "").split(",");
        double[] valores = convertirStringADoubleArray(valuesGG);

        ImageCreator.createPieChartImage(categorias,valores,tituloGG);
        arregloTemporal="";
        arregloNumeros="";
        tituloGG="";
        valuesGG="";
        labelGG="";
        :};

linea::= RESERVADA_GRAFICA_LINE
        PARENTESIS_IZQUIERDO

        sentencias
        sentencias
        sentencias
        sentencias
        sentencias

        RESERVADA_EXEC RESERVADA_GRAFICA_LINE RESERVADA_END PUNTO_Y_COMA
     
        PARENTESIS_DERECHO  RESERVADA_END  PUNTO_Y_COMA

{:

        String[] categorias = ejexGG.replaceAll("\"", "").split(",");
        double[] valores = convertirStringADoubleArray(ejeyGG);
        
        ImageCreator.createLineChartImage(categorias,valores,tituloGG,tituloxGG,tituloyGG);
        arregloTemporal="";
        arregloNumeros="";
        tituloGG="";
        ejexGG="";
        ejeyGG="";
        tituloxGG="";
        tituloyGG="";
        :};


histograma::= 
        RESERVADA_GRAFIA_HISTOGRAMA
        PARENTESIS_IZQUIERDO

        sentencias3
        sentencias3

        RESERVADA_EXEC RESERVADA_GRAFIA_HISTOGRAMA  RESERVADA_END PUNTO_Y_COMA
     
        PARENTESIS_DERECHO  RESERVADA_END  PUNTO_Y_COMA
        {:  
         double[] valores;
         System.out.println(valuesGG);
         valores = convertirStringADoubleArray(valuesGG);
  
         int[] arregloInt = new int[valores.length];

         for (int i = 0; i < valores.length; i++) {
            String valorComoCadena = Double.toString(valores[i]).replace(".", "");
            arregloInt[i] = Integer.parseInt(valorComoCadena);
        }
        
        ImageCreator.createHistogramImage(arregloInt,tituloGG);

        String r="\n                                "+tituloGG+"\n";
        r=r+"============================================="+"\n";
        r=r+"Valor                  Fb                      Fa                      Fr"+"\n";
        r=r+"============================================="+"\n";
        double[] sinR = obtenerArregloSinRepetidos(valores);
        int[] frec = obtenerFrecuencia(valores);
        //int[] arreg = convertirDoubleAInt(valores);
        int[] frecA = obtenerFrecuenciaAcumulada(frec);
        double[] frecR = obtenerFrecuenciaRelativa(frec, valores.length);
        r =r+concatenarArreglos(sinR, frec, frecA, frecR);
        int up = frecA.length - 1;
        int upp = frecA[up];
        r=r+"============================================="+"\n";
        r=r+"Totales              "+upp+"                       "+upp+"                         100%"+"\n";
        r=r+"============================================="+"\n";

        System.out.println("\n"+"Print desde el cup de la cadena: " + r+"\n");
        gui.listaPrint.add((String) r); 

        arregloTemporal="";
        arregloNumeros="";
        valuesGG="";
        tituloGG="";
        :};



